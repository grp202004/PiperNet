import { makeAutoObservable } from "mobx";
import Graph from "graphology";
import State from ".";
import {
    ForceGraphMethods,
    LinkObject,
    NodeObject,
} from "react-force-graph-3d";
import Cluster3dObjectStore from "./Cluster3dObjectStore";

export type Partial<T> = {
    [P in keyof T]?: T[P];
};

/**
 * @description
 * hovered: false, selected: false: DefaultColor;
 * hovered: false, selected: true: SelectedColor;
 * hovered: true, selected: false: HighlightColor;
 * hovered: true, selected: true: HighlightColor;
 * @author Zichen XU
 * @export
 * @interface ICustomNodeObject
 * @extends {NodeObject}
 */
export interface ICustomNodeObject extends NodeObject {
    hovered: boolean;
    chosen: boolean;
    multiSelected: boolean;
    isClusterNode?: boolean;
}

/**
 * @description
 * hovered: false, selected: false: DefaultColor;
 * hovered: false, selected: true: SelectedColor;
 * hovered: true, selected: false: HighlightColor;
 * hovered: true, selected: true: HighlightColor;
 * @author Zichen XU
 * @export
 * @interface ICustomLinkObject
 * @extends {LinkObject}
 */
export interface ICustomLinkObject extends LinkObject {
    chosen: boolean;
    hovered: boolean;
    isClusterLink?: boolean;
}

/**
 * @description create a default CustomNodeObject by specifying the id
 * and whether this node is the cluster node
 * @author Zichen XU
 * @export
 * @param {string} _id
 * @param {boolean} [_cluster=false]
 * @returns {*}  {ICustomNodeObject}
 */
export function createCustomNodeObject(
    _id: string,
    _cluster: boolean = false
): ICustomNodeObject {
    return {
        id: _id,
        hovered: false,
        chosen: false,
        multiSelected: false,
        isClusterNode: _cluster,
    };
}

/**
 * @description create a default CustomLinkObject by specifying the source and target id
 * and whether this node is the cluster link
 * @author Zichen XU
 * @export
 * @param {string} _source
 * @param {string} _target
 * @param {boolean} [_cluster=false]
 * @returns {*}  {ICustomLinkObject}
 */
export function createCustomLinkObject(
    _source: string,
    _target: string,
    _cluster: boolean = false
): ICustomLinkObject {
    return {
        source: _source,
        target: _target,
        hovered: false,
        chosen: false,
        isClusterLink: _cluster,
    };
}

/**
 * @description acts as a bridge between the graphology graph data structure and the 3d-force-graph we use to render the 3D scene
 * The visualizationGraph() will compute the clustered graph to be send to 3d-renderer
 * The cluster data generated by ClusterStore will be used in this process.
 *
 * we define some customized interfaces ICustomNodeObject and ICustomLinkObject which extends from the Node/LinkObject of 3d-force-graph
 * with adding fields like hovered, selected and multiSelected to deal with the WebGL mouse interaction.
 * This class also includes reference to the React.Ref of 3d-renderer
 * with providing functions like auto-focus the camera as well as update the force inside the cluster.
 * @author Zichen XU
 * @export
 * @class GraphDelegate
 */
export default class GraphDelegate {
    constructor() {
        makeAutoObservable(this);
        this.clusterObject = new Cluster3dObjectStore();
    }

    /**
     * @description assign the force-graph methods to this class
     * should be called as long as the visualizer react component is mounted
     * @author Zichen XU
     * @param {ForceGraphMethods} _graphDelegateMethods
     */
    mountDelegateMethods(_graphDelegateMethods: ForceGraphMethods) {
        this.graphDelegateMethods = _graphDelegateMethods;
        this.clusterObject.threeScene = this.graphDelegateMethods.scene();
    }

    /**
     * @description the ForceGraphMethods exposed by the visualization force-graph
     * @author Zichen XU
     * @see ForceGraphMethods
     * @type {ForceGraphMethods}
     */
    graphDelegateMethods!: ForceGraphMethods;

    /**
     * @description compute the delegate graph that will be used by the ForceGraph3D
     * will add invisible cluster nodes and edges to balance the clustered graph and adjust force
     * the NodeObject and LinkObject inside attributes (named _visualize) will be used.
     *
     * @author Zichen XU
     * @returns {*}
     */
    visualizationGraph() {
        let newGraph: Graph;
        if (State.cluster.clusterBy === null) {
            newGraph = State.graph.rawGraph;
        } else {
            newGraph = this.addInvisibleClusterNode(
                State.graph.decorateRawGraph(State.graph.rawGraph)
            );
        }
        let tempGraph = {
            nodes: [] as ICustomLinkObject[],
            links: [] as ICustomLinkObject[],
        };
        newGraph.forEachNode((node, attributes) => {
            tempGraph.nodes.push(attributes["_visualize"]);
        });

        newGraph.forEachEdge((edge, attributes) => {
            tempGraph.links.push(attributes["_visualize"]);
        });
        return tempGraph;
    }

    /**
     * @description return a new graph that contains the invisible clusters, formed as nodes
     * as well as the edges that connected to the cluster node to simulate the force within the same cluster
     * the new graph is a deep copy of the old node, so no worries of the original graph DS
     * @author Zichen XU
     * @private
     * @param {Graph} oldGraph
     * @returns {*}  {Graph}
     */
    private addInvisibleClusterNode(oldGraph: Graph): Graph {
        let graphCopy = oldGraph.copy();
        let names = [
            "_CLUSTER_1_",
            "_CLUSTER_2_",
            "_CLUSTER_3_",
            "_CLUSTER_4_",
            "_CLUSTER_5_",
            "_CLUSTER_6_",
            "_CLUSTER_7_",
            "_CLUSTER_8_",
            "_CLUSTER_9_",
            "_CLUSTER_10_",
        ];
        for (let index = 0; index < names.length; index++) {
            State.cluster.getAttributeValues.forEach(
                (attribute: string | number) => {
                    // if a node does not belong to any cluster, a undefined will be formed with no cluster to generate
                    if (attribute === "undefined") return;

                    let clusterID = names[index] + attribute;
                    graphCopy.addNode(clusterID, {
                        _visualize: createCustomNodeObject(clusterID, true),
                    });

                    // add edges to simulate the force of the same cluster
                    State.cluster.attributeKeys
                        .get(attribute)
                        ?.forEach((target) => {
                            graphCopy.addEdgeWithKey(
                                `${clusterID}-${target}`,
                                clusterID,
                                target,
                                {
                                    _visualize: createCustomLinkObject(
                                        clusterID,
                                        target,
                                        true
                                    ),
                                }
                            );
                        });
                }
            );
        }

        return graphCopy;
    }

    /**
     * @description determine whether this Node is the cluster delegate node
     * @author Zichen XU
     * @param {NodeObject} nodeObject
     * @returns {*}
     */
    nodeVisibility(nodeObject: NodeObject) {
        let node = nodeObject as ICustomNodeObject;
        return !node.isClusterNode;
    }

    /**
     * @description determine whether this edge is the cluster delegate edge
     * @author Zichen XU
     * @param {LinkObject} linkObject
     * @returns {*}
     */
    linkVisibility(linkObject: LinkObject) {
        let link = linkObject as ICustomLinkObject;
        return !link.isClusterLink;
    }

    ////

    /**
     * @description the link to Cluster3dObjectStore to manipulate the cluster related to WebGL
     * @author Zichen XU
     * @type {Cluster3dObjectStore}
     */
    clusterObject: Cluster3dObjectStore;

    ////

    /**
     * @description this will re-position the camera to focus on the specified node
     * if distance not specified, a default of 40 will be used
     * @author Zichen XU
     * @param {string} nodeId the node to be focused
     * @param {number} [distance=40] the ending distance between the camera and the node
     * @returns {*}
     */
    cameraFocusOn(nodeId: string, distance: number = 80) {
        let node = State.graph.rawGraph.getNodeAttribute(nodeId, "_visualize");
        if (!(node.x && node.y && node.z)) return;
        // Aim at node from outside it
        const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);

        this.graphDelegateMethods.cameraPosition(
            {
                x: node.x * distRatio,
                y: node.y * distRatio,
                z: node.z * distRatio,
            }, // new position
            { x: node.x, y: node.y, z: node.z }, // lookAt ({ x, y, z })
            3000 // ms transition duration
        );
    }

    ////

    /**
     * @description set the force inside each cluster in the ForceGraph
     * @author Zichen XU
     */
    updateClusterForce() {
        this.graphDelegateMethods
            ?.d3Force("link")
            //@ts-ignore
            ?.distance((link: CustomLinkObject) => {
                return link.isClusterLink
                    ? State.css.cluster.clusterForce
                    : State.css.cluster.normalForce;
            });
        this.graphDelegateMethods.d3ReheatSimulation();
    }
}
